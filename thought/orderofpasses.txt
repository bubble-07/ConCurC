Begin by lexing, parsing
Then reorder known primitives
Recursively scan for dependencies of the files [make a graph, not necessarily acyclic], create
    file structure in memory
Process in reverse topological order, with circularly dependent files processed as one [for each
    of the following]
    Note: types are qualified just like function names! [CRITICAL]
Scan for type definitions relavant to macro-ing [pop from source program]
Find the transitive closure of macro types
Find function definitions referencing macro types, load into memory
Lexically scope macro function definitions (turn them into a proper DAG)
Search and destroy within the rest of the program text [evaluation according to rules]

Dependency-determination: single file:
    1. Compile a list of applicable outer-file "roots"
    2. Search for these "roots" at the bottom of the AST, then, if one is found:
        a. The parent is checked to see if it is a file/directory within its' child's directory
        b. If it is, recursively continue this process for the next "root".
        c. If it isn't, terminate, flatten into an "absolute reference", and add the child's
        absolute reference to the global set for the file's dependencies.
Dependency-determination: general:
    I. If the given file path already has not been logged in the global dict:
        a. For file A, find its dependencies
        b. Log file A and its' location in a global dictionary from file refs to programs
        c. Recursively call the dependency-determination procedure on its dependencies
    II. Return

Macro type resolution:
    I. Resolve all macro type declarations at top level in the first file in the 
    reverse-topological ordering of the dependency graph of files. (construct a graph)
    II. Transfer macro types to usable format
    III. 

Resulting structure we want:
    


